<p>Note that project grading is <mark>not competitive (not bell curved)</mark>. <mark>CS2103T projects will be assessed separately from CS2103 projects.</mark> This is to account for the perceived difference in workload. Given below is the marking scheme.</p>
<p><strong>Total</strong>: 50 marks (40 individual marks + 10 team marks)</p>
<ol>
  <li>
    <p><strong>Product features</strong> [team][5 marks] - How well do your features fit together</p>
    <p>Based on how well the features implemented fit together to make a good product (not how many features or how big the features are), and how well they are demonstrated.</p>
    <p>‘Half-baked’ (i.e. not production quality) or 'ill-fitting' (feature does not go well with the other features) features will not earn marks at all and could even be penalized. It may be better to remove such features before submission.</p>
  </li>
  <li>
    <p><strong>Implementation</strong> [individual][20 marks] - How good is your implementation? A measure of the <mark>quality and the quantity</mark> of code you have written yourself. Evaluated based on an inspection of the collated code (submitted in
      your <code>/collated/*.md</code> files).</p>
  </li>
  <li>
    <p><strong>QA</strong> [individual][10 marks] - How good is your Quality Assurance? Evaluated based on your test code and our own manual testing.</p>
    <p>Expectations:</p>
    <ul>
      <li>There is no requirement for a minimum coverage level. Note that in a production environment you are often required to have at least 90% of the code covered by tests. In this project, it can be less.</li>
      <li>How much of each type of testing should you do? We expect you to decide. You learned different types of testing and what they try to achieve. Based on that, you should decide how much of each type is required. Similarly, you can decide to what extent
        you want to automate tests, depending on the benefits and the effort required.</li>
      <li>Applying TDD is optional. If you plan to test something, it is better to apply TDD because TDD ensures that you write functional code in a testable way. If you do it the normal way, you often find that it is hard to test the functional code because
        the code has low testability.</li>
    </ul>
  </li>
  <li>
    <p><strong>Documentation</strong> [individual][10 marks] - How well does your user guide achieves its objectives? Evaluated based on the relevant sections of your project portfolio.<br> Criteria considered:</p>
    <ul>
      <li>Explanation should be clear and written to match the audience.</li>
      <li>Good use of visuals to complement text.</li>
    </ul>
  </li>
  <li>
    <p><strong>Project management</strong> [team: 5 marks] - How well you worked together as a team to follow a systematic process? Evaluated based on Github data and supervisor observations.<br> Criteria:
    </p>
    <ul>
      <li>Good use of GitHub milestones.</li>
      <li>Good use of GitHub release mechanism.</li>
      <li>Good version control, based on the repo.</li>
      <li>Reasonable attempt to use the forking workflow.</li>
      <li>Good task definition, assignment and tracking, based on the issue tracker.</li>
      <li>Good use of buffers (opposite: everything at the last minute)</li>
      <li>Iterative (opposite: fake iterative, doing most of the work in one iteration).</li>
      <li>Passed almost all checkpoints from v1.0 to v1.5</li>
    </ul>
  </li>
</ol>
<p><strong>Penalty for late submission:</strong><mark>-1 mark for each hour delayed.</mark> Even a 1-second delay is penalized, irrespective of the reason. Based on the time shown by IVLE.</p>